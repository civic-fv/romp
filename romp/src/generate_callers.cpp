/**
 * @proj romp
 * @author Andrew Osterhout
 * @author Ajantha Varadharaaj
 * @org University of Utah (UofU) School of Computing (SoC)
 * @org Center for Parallel compute at Utah (CPU)
 * @org <a href="https://civic-fv.github.io">Civic-fv NSF Grant</a>
 * @org Ganesh Gopalakrishnan's Research Group
 * @file generate_callers.cpp
 * 
 * @brief generate all of the ruleset expansion callers for the model.
 * 
 * @date 2022/10/19
 * @version 0.3
 */

#include "generate_callers.hpp"
#include "SigPerm.hpp"
#include "nested_escape.hpp"
#include <murphi/murphi.h>
#include <murphi/traverse.h>
#include <sstream>

namespace romp {

  using namespace murphi;



// CodeGenerator& operator << (CodeGenerator& out, const Sig& sig) {
//   out << sig.perm.rule.name << "(";
//   std::string sep;
//   for (size_t i=0; i<sig.size(); ++i) 
//     if (sig.params[i] != nullptr) {
//       out << sep << *sig.params[i];
//       sep = ", ";
//     }
//   return (out << ")");
// }




// << ------------------------------------------------------------------------------------------ >> 

void generate_ruleset_callers(romp::CodeGenerator& gen, const murphi::Model& m) {
  struct Generator : public murphi::ConstTraversal {
    CodeGenerator& gen;
    id_t info_id = 0;
    size_t rule_count = 0;
    size_t max_count = 0;
    std::stringstream ruleset_array;
    std::string rs_sep = "\n\t\t";
    Generator(CodeGenerator& gen_) : gen(gen_) {}
    void visit_model(const Model& m) final {
       for (const Ptr<Node> &c : m.children)
        if (auto r = dynamic_cast<const Rule *>(c.get())) {
          std::vector<Ptr<Rule>> rs = r->flatten();
          for (const Ptr<Rule> &r2 : rs)
            dispatch(*r2);
        }
    }

    void visit_simplerule(const SimpleRule& n) final {
      // const SimpleRule& rule = *_rule;
      const SimpleRule& rule = n;
      ruleset_array << rs_sep << ROMP_MAKE_RULESET_STRUCT_HEADER(info_id);
      // size_t rule_c = 0;
      gen << gen.indentation() << "/* --- Rules Generated by: `" << rule.name << "` (RuleSet expansions) --- */\n";
      SigPerm sigs(rule);
      if (max_count < sigs.size())
          max_count = sigs.size();
      rule_count += sigs.size();
      std::stringstream _sig_str;
      std::string r_sep = "";
      for (const Sig& sig : sigs) {
        // _sig_str << sig;
        // std::string sig_str(_sig_str.str()); sig_str += " ";
        std::string _guard = ROMP_RULE_GUARD_PREFIX + rule.name + "__" + std::to_string(sig.index);  // int_to_hex(sig.index);
        std::string _action = ROMP_RULE_ACTION_PREFIX + rule.name + "__" + std::to_string(sig.index); // int_to_hex(sig.index);
        ruleset_array << r_sep << ROMP_MAKE_RULE_STRUCT(_guard,_action,info_id,sig.to_json(),sig.to_string());
        gen   << gen.indentation()
              << gen.M_RULE_GUARD__FUNC_ATTRS
              << " bool "
              << _guard
              << "(const " ROMP_STATE_TYPE "& s) { using namespace " ROMP_MODEL_NAMESPACE_NAME "; "
              "return s." ROMP_RULE_GUARD_PREFIX << sig.gen_call()/* _str */ << "; }\n"
              << gen.indentation()
              << gen.M_RULE_ACTION__FUNC_ATTRS
              << " void "
              << _action
              << "(" ROMP_STATE_TYPE "& s) { using namespace " ROMP_MODEL_NAMESPACE_NAME "; "
              "s." ROMP_RULE_ACTION_PREFIX << sig.gen_call()/* _str */ << "; }\n";
        // rule_count++;
        r_sep = ", ";
      }
      ruleset_array << gen.indentation() << "\t" ROMP_MAKE_RULESET_STRUCT_FOOTER();
      rs_sep = ",\n\t\t";
      ++info_id;
      gen << /*std::*/gen.flush();
    }
  };
  Generator generator(gen);
  generator.dispatch(m);
  gen << "\n#define " ROMP_RULES_LEN " (" << generator.rule_count << "ul)\n"
      << "\n#define " ROMP_RULESETS_LEN " (" << generator.info_id << "ul)\n"
      << "\n#define _ROMP_MAX_RULESET_RULE_COUNT (" << generator.max_count << "ul)\n"
      << gen.indentation() << ROMP_CALLER_RULESETS_DECL " = {" << generator.ruleset_array.str() << "};\n"
      << /*std::*/gen.flush();
}


// << ------------------------------------------------------------------------------------------ >> 


void generate_property_rule_callers(romp::CodeGenerator& gen, const murphi::Model& m) {
  struct Generator : public murphi::ConstTraversal {
    CodeGenerator& gen;
    id_t _lid = 0;
    size_t count_invar = 0u;
    size_t count_assume = 0u;
    size_t count_cover = 0u;
    size_t count_liveness = 0u;
    size_t count = 0;
    std::stringstream prop_list;
    Generator(CodeGenerator& gen_) : gen(gen_) {}
    void visit_model(const Model& m) final {
       for (const Ptr<Node> &c : m.children)
        if (auto r = dynamic_cast<const Rule *>(c.get())) {
          std::vector<Ptr<Rule>> rs = r->flatten();
          for (const Ptr<Rule> &r2 : rs)
            dispatch(*r2);
        }
    }
    void visit_propertystmt(const PropertyStmt& n) final { ++_lid; }

    void visit_propertyrule(const PropertyRule& n) final {
      // const PropertyRule& prop = *_prop;
      const PropertyRule& prop = n;
      gen << gen.indentation() << "/* --- Property Rule(s) generated by: `" << prop.name << "` (RuleSet expansions) --- */\n";
      SigPerm sigs(prop);
      for (auto& sig : sigs) {
        std::string _check = ROMP_PROPERTYRULE_PREFIX + prop.name + "__" + std::to_string(sig.index);  // int_to_hex(sig.index);
        gen << gen.indentation() 
            << gen.M_PROPERTY__FUNC_ATTRS
            // << " void "
            << " bool "
            << _check
            << "(const " ROMP_STATE_TYPE "& s) { using namespace " ROMP_MODEL_NAMESPACE_NAME "; "
               "return s." ROMP_PROPERTYRULE_PREFIX << sig.gen_call() << "; }\n";
        switch (prop.property.category) {
        case Property::ASSERTION:
          prop_list << "\t\t" << ROMP_MAKE_PROPERTY_STRUCT(_check,_lid,sig.to_json(),sig.to_string()) << ",\n";
          ++count_invar;
          break;
        case Property::ASSUMPTION:
          prop_list << "#ifdef " ROMP_ASSUME_PREPROCESSOR_VAR "\n\t\t"
                    << ROMP_MAKE_PROPERTY_STRUCT(_check,_lid,sig.to_json(),sig.to_string()) << ",\n"
                       "#endif\n";
          ++count_assume;
          break;
        case Property::COVER:
          prop_list << "#ifdef " ROMP_COVER_PREPROCESSOR_VAR "\n\t\t"
                    << ROMP_MAKE_PROPERTY_STRUCT(_check,_lid,sig.to_json(),sig.to_string()) << ",\n"
                       "#endif\n";
          ++count_cover;
          break;
        case Property::LIVENESS:
          prop_list << "#ifdef " ROMP_COVER_PREPROCESSOR_VAR "\n\t\t"
                    << ROMP_MAKE_PROPERTY_STRUCT(_check,_lid,sig.to_json(),sig.to_string()) << ",\n"
                       "#endif\n";
          ++count_liveness;
          break;
        }
      }
      ++_lid;
    }
  };
  Generator generator(gen);
  generator.dispatch(m);
  gen << "\n#ifdef " ROMP_ASSUME_PREPROCESSOR_VAR "\n"
          "#define ___propRule_assume_count___ (" << generator.count_assume << "ul)\n"
          "#else\n"
          "#define ___propRule_assume_count___ (0ul)\n"
          "#endif\n"
          "#ifdef " ROMP_COVER_PREPROCESSOR_VAR "\n"
          "#define ___propRule_cover_count___ (" << generator.count_cover << "ul)\n"
          "#else\n"
          "#define ___propRule_cover_count___ (0ul)\n"
          "#endif\n"
          "#ifdef " ROMP_LIVENESS_PREPROCESSOR_VAR "\n"
          "#define ___propRule_liveness_count___ (" << generator.count_liveness << "ul)\n"
          "#else\n"
          "#define ___propRule_liveness_count___ (0ul)\n"
          "#endif\n";
    gen << "\n/* the number of property rules (after ruleset expansion) in the model */\n"
             "#define " ROMP_PROPERTY_RULES_LEN " ((" << generator.count_invar << "ul) "
                                                  "+ ___propRule_assume_count___ "
                                                  "+ ___propRule_cover_count___ "
                                                  "+ ___propRule_liveness_count___)\n"
        << "\n/* All of the property rules expanded in one place */\n" 
          << ROMP_CALLER_PROPERTIES_DECL " = {\n"  << generator.prop_list.str() << "};\n"
        << /*std::*/gen.flush();
}


// << ------------------------------------------------------------------------------------------ >> 


void generate_startstate_callers(romp::CodeGenerator& gen, const murphi::Model& m) {
  struct Generator : public murphi::ConstTraversal {
    CodeGenerator& gen;
    id_t info_id = 0;
    size_t count = 0;
    std::stringstream list;
    std::string sep;
    Generator(CodeGenerator& gen_) : gen(gen_) {}
    void visit_model(const Model& m) final {
       for (const Ptr<Node> &c : m.children)
        if (auto r = dynamic_cast<const Rule *>(c.get())) {
          std::vector<Ptr<Rule>> rs = r->flatten();
          for (const Ptr<Rule> &r2 : rs)
            dispatch(*r2);
        }
    }

    void visit_startstate(const StartState& n) final {
      // const StartState& startstate = *_startstate;
      const StartState& startstate = n; // *startstates[i];
      gen << gen.indentation() << "/* --- StartState Rule(s) generated by: `" << startstate.name << "` (RuleSet expansions) --- */\n";
      SigPerm sigs(startstate);
      for (auto& sig : sigs) {
        std::string _init = ROMP_STARTSTATE_PREFIX + startstate.name + "__" + std::to_string(sig.index);  // int_to_hex(sig.index);
        gen << gen.indentation() 
            << gen.M_STARTSTATE__FUNC_ATTRS
            << " void "
            << _init
            << "(" ROMP_STATE_TYPE "& s) { using namespace " ROMP_MODEL_NAMESPACE_NAME "; "
               "s." ROMP_STARTSTATE_PREFIX << sig.gen_call() << "; }\n";
        list << sep << ROMP_MAKE_STARTSTATE_STRUCT(_init,count,info_id,sig.to_json(),sig.to_string());
        sep = ", ";
        ++count;
      }
      ++info_id;
    }
  };
  Generator generator(gen);
  generator.dispatch(m);
  gen << "\n\n#define " ROMP_STARTSTATE_RULES_LEN " (" << generator.count <<  "ul) // the number of property rules (after ruleset expansion) in the model\n"
      << gen.indentation() << "// all of the startstates in one place (post ruleset expansion)\n"
      << gen.indentation() << ROMP_CALLER_STARTSTATES_DECL " = {" << generator.list.str() << "};\n"
      << /*std::*/gen.flush();
}

}  // namespace romp
